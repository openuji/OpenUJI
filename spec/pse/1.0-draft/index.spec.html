<section id="abstract">
  <p>
    This specification defines an abstract, platform-agnostic model for a
    programmable, one-dimensional scroll engine. It describes scroll domains,
    observable state, and a architecture in which host or application code can
    participate in scroll decisions via programmable hooks, extension points,
    and explicit
    <a href="#term-scroll-authority">scroll authority</a> configuration.
  </p>
  <p>
    The model distinguishes between user-originated and programmatic scrolling,
    and allows host environments to choose whether the scroll engine or the host
    itself applies motion to the scroll surface for each origin, while ensuring
    that the engine can still observe and coordinate scroll state.
  </p>
  <p>
    The model includes special support for circular scroll domains suitable for
    storytelling and looping interfaces, but does not prescribe a particular
    user interface, rendering technology, or animation API.
  </p>
  <p>
    The model is intended to be implementable across a variety of host
    environments, including web browsers, Android, iOS, and other native or
    embedded runtimes, while remaining agnostic to specific animation or
    rendering APIs.
  </p>
</section>

<section id="sotd">
  <p>
    This is an unofficial draft. It is not a W3C Standard, and it has not
    received any formal review. The contents of this document may change at any
    time.
  </p>
</section>

<section id="intro">
  <h2 id="intro-heading">Introduction</h2>

  <section id="intro-purpose">
    <h3 id="intro-purpose-heading">Purpose</h3>
    <p>
      Many interactive experiences, including narrative and storytelling
      interfaces, require scroll behaviors that go beyond conventional bounded
      content scrolling. Examples include circular or looping scrolls, custom
      motion profiles, scroll-linked effects, and scroll state that persists
      across navigations or app sessions.
    </p>
    <p>
      This specification defines a <em>Programmable Scroll Engine Model</em>: an
      abstract description of how a one-dimensional scroll axis is represented,
      controlled, and extended. The model is intended to:
    </p>
    <ul>
      <li>
        Support a variety of scroll domains, including bounded, unbounded, and
        circular domains.
      </li>
      <li>
        Expose programmable hooks for host or application code to observe,
        modify, and respond to scroll behavior, without prescribing concrete API
        shapes.
      </li>
      <li>
        Enable rich control over scroll trajectories (for example, smoothness,
        easing, and custom motion policies) via pluggable components instead of
        fixed behavior.
      </li>
      <li>
        Provide a predictable basis for scroll state persistence across
        navigations and app sessions.
      </li>
      <li>
        Support explicit configuration of which component is responsible for
        applying scroll motion to the scroll surface for user-originated and
        programmatic actions, via
        <a href="#term-scroll-authority">scroll authority</a>.
      </li>
      <li>
        Be implementable across multiple platforms and UI toolkits, such as web,
        Android, iOS, game engines, and custom runtime environments.
      </li>
    </ul>
  </section>

  <section id="intro-scope">
    <h3 id="intro-scope-heading">Scope</h3>
    <p>
      This document defines the abstract data model and high-level architecture
      of a programmable scroll engine. It does not define concrete API surface
      or language bindings for specific platforms. Instead, it is expected that
      separate <em>binding specifications</em>
      will define how this model maps to:
    </p>
    <ul>
      <li>DOM and CSSOM View APIs in web browsers,</li>
      <li>
        native scroll views and list views on platforms such as Android and iOS,
      </li>
      <li>and other host-specific scroll surfaces.</li>
    </ul>
    <p>
      This edition intentionally omits detailed algorithms for frame stepping,
      motion policies, input handling, and specific plugin or middleware
      formats. It defines abstract extension points and programmable hooks;
      concrete mechanisms for expressing
      <a href="#term-scroll-program">scroll programs</a>,
      <a href="#term-motion-policy">motion policies</a>, plugins, and
      host-specific <a href="#term-scroll-authority">scroll authority</a>
      configuration may be specified in future modules or host-specific
      bindings.
    </p>
  </section>

  <section id="intro-out-of-scope">
    <h3 id="intro-out-of-scope-heading">Out of Scope</h3>
    <p>The following are out of scope for this edition of the specification:</p>
    <ul>
      <li>
        Detailed algorithms for animation loops, schedulers, and motion
        policies.
      </li>
      <li>
        Concrete APIs (function signatures, classes, or IDL) for specific
        platforms.
      </li>
      <li>
        The definition of user interface design, layout, or content structure
        beyond what is needed to specify scroll behavior.
      </li>
      <li>
        The definition of concrete bindings to platform-specific animation or
        timing APIs (for example, native animation frameworks or the Web
        Animations API). Such bindings <em class="rfc2119">MAY</em> be defined
        in separate documents.
      </li>
      <li>
        The definition of concrete mechanisms by which host environments apply
        scroll updates to scroll surfaces (for example, specific methods or
        properties). This specification only constrains observable behavior and
        <a href="#term-scroll-authority">authority</a> semantics.
      </li>
    </ul>
  </section>
</section>

<section id="conformance">
  <h2 id="conformance-heading">Conformance</h2>
  <p>
    As well as sections marked as non-normative, all authoring guidelines,
    diagrams, examples, and notes in this specification are non-normative.
    Everything else in this specification is normative.
  </p>
  <p>
    The key words <em class="rfc2119">MUST</em>,
    <em class="rfc2119">MUST NOT</em>, <em class="rfc2119">REQUIRED</em>,
    <em class="rfc2119">SHALL</em>, <em class="rfc2119">SHALL NOT</em>,
    <em class="rfc2119">SHOULD</em>, <em class="rfc2119">SHOULD NOT</em>,
    <em class="rfc2119">RECOMMENDED</em>, <em class="rfc2119">MAY</em>, and
    <em class="rfc2119">OPTIONAL</em> in this document are to be interpreted as
    described in <a data-cite="RFC2119">RFC2119</a>.
  </p>

  <section id="conformance-implementations">
    <h3 id="conformance-implementations-heading">
      Conforming Scroll Engine Implementations
    </h3>
    <p>
      A <dfn>Scroll Engine Implementation</dfn> is any library, module, or
      component that provides logic for controlling a single scroll axis in
      accordance with this specification.
    </p>
    <p>
      A conforming Scroll Engine Implementation
      <em class="rfc2119">MUST</em>:
    </p>
    <ul>
      <li>
        Represent a single scroll axis with an associated
        <a href="#scroll-domain">scroll domain</a>.
      </li>
      <li>
        Maintain and provide access to the observable state described in
        <a href="#data-observable-state">Engine Observable State</a>.
      </li>
      <li>
        Accept both programmatic
        <a href="#term-scroll-operation">scroll operations</a> and
        user-originated <a href="#term-impulse">impulses</a>.
      </li>
      <li>
        Distinguish the <a href="#term-origin">origin</a> of position updates
        (for example, user, program, or momentum).
      </li>
      <li>
        Respect the configured
        <a href="#term-user-scroll-authority">user scroll authority</a> and
        <a href="#term-programmatic-scroll-authority"
          >programmatic scroll authority</a
        >
        as defined in <a href="#term-scroll-authority">Scroll Authority</a>,
        including:
        <ul>
          <li>
            not applying user-originated impulses directly to the scroll surface
            when the host is configured as the authority for user scroll, and
          </li>
          <li>
            not applying programmatic scroll operations directly when the host
            is configured as the authority for programmatic scroll.
          </li>
        </ul>
      </li>
      <li>
        Provide an observable mechanism for clients to track changes in scroll
        position and origin, as described in
        <a href="#data-signals">Signals and Origins</a>.
      </li>
      <li>
        Expose one or more programmable extension points, as described in
        <a href="#data-programmability">Programmable Extension Points</a>, such
        that host or application code can observe and, where allowed, influence
        scroll behavior without violating the semantics of the active scroll
        domain or configured scroll authorities.
      </li>
    </ul>
    <p>
      Conforming Scroll Engine Implementations
      <em class="rfc2119">MAY</em> use any internal representation or underlying
      platform primitives, as long as the externally observable behavior and
      extension semantics conform to this specification.
    </p>
  </section>

  <section id="conformance-hosts">
    <h3 id="conformance-hosts-heading">Conforming Host Environments</h3>
    <p>
      A <dfn>Host Environment</dfn> is any runtime or platform that embeds a
      conforming Scroll Engine Implementation and provides a visible scroll
      surface. Examples include web browsers, Android or iOS applications, game
      engines, or desktop UI toolkits.
    </p>
    <p>
      A conforming Host Environment
      <em class="rfc2119">MUST</em>:
    </p>
    <ul>
      <li>
        Provide at least one <dfn>scroll surface</dfn>: a host-defined entity
        whose visible content is moved in response to changes in scroll position
        (for example, a DOM element, a native scroll view, or a camera
        transform).
      </li>
      <li>
        Define how scroll positions in the scroll engine map to the scroll
        surface (for example, mapping canonical positions to pixel-based offsets
        or item indices).
      </li>
      <li>
        Define how user input and lifecycle events in the host environment are
        translated into <a href="#term-impulse">impulses</a>,
        <a href="#term-scroll-operation">scroll operations</a>, and persistence
        operations for the scroll engine.
      </li>
      <li>
        Configure
        <a href="#term-user-scroll-authority">user scroll authority</a> and
        <a href="#term-programmatic-scroll-authority"
          >programmatic scroll authority</a
        >
        for each scroll surface and/or scroll axis, and ensure that the engine
        and host consistently apply scroll motion in accordance with that
        configuration.
      </li>
      <li>
        Ensure that, regardless of scroll authority configuration, the scroll
        engine can observe resulting canonical positions, origins, and motion
        such that scroll programs remain coherent.
      </li>
      <li>
        Integrate accessibility-related constraints and behaviors as described
        in <a href="#accessibility">Accessibility</a>.
      </li>
      <li>
        Ensure that any host-specific APIs or bindings to the scroll engine do
        not conflict with platform-native animation or timing APIs, and clearly
        distinguish programmable scroll behavior from other forms of animation.
      </li>
    </ul>
  </section>
</section>

<section id="terminology">
  <h2 id="terminology-heading">Terminology</h2>

  <section id="term-scroll-axis">
    <h3 id="term-scroll-axis-heading">Scroll Axis</h3>
    <p>
      A <dfn>scroll axis</dfn> is a single logical dimension along which
      scrolling occurs. A scroll axis does not assume a particular physical
      direction; mapping to horizontal or vertical movement is defined by the
      host environment.
    </p>
  </section>

  <section id="term-scroll-position">
    <h3 id="term-scroll-position-heading">Scroll Position</h3>
    <p>
      A <dfn>scroll position</dfn> is a real-valued coordinate on a scroll axis.
    </p>
    <p>The model distinguishes two related notions of position:</p>
    <ul>
      <li>
        A <dfn>canonical position</dfn> is the scroll position normalized into
        the canonical range of the active
        <a href="#scroll-domain">scroll domain</a> (for example,
        <code>[min, max]</code> for a bounded domain or
        <code>[min, min + period)</code> for circular domains).
      </li>
      <li>
        A <dfn>logical position</dfn> is an internal representation of position
        that <em class="rfc2119">MAY</em> differ from the canonical position by
        integer multiples of the domain’s period, particularly in circular
        domains. Logical positions are used to represent potentially unbounded
        motion over time.
      </li>
    </ul>
  </section>

  <section id="scroll-domain">
    <h3 id="scroll-domain-heading">Scroll Domain</h3>
    <p>
      A <dfn>scroll domain</dfn> describes the allowed range of scroll positions
      and how positions behave at or beyond the edges of that range. The kinds
      of scroll domains are defined in
      <a href="#data-domains">Scroll Domains</a>.
    </p>
  </section>

  <section id="term-scroll-operation">
    <h3 id="term-scroll-operation-heading">Scroll Operation</h3>
    <p>
      A <dfn id="term-scroll-operation">scroll operation</dfn> is a programmatic
      request to change the scroll position. A scroll operation typically
      specifies a desired target position and possibly additional motion
      parameters (such as instantaneous vs. animated movement).
    </p>
  </section>

  <section id="term-impulse">
    <h3 id="term-impulse-heading">Impulse</h3>
    <p>
      An <dfn id="term-impulse">impulse</dfn> is a discrete change in scroll
      position originating from user interaction, such as:
    </p>
    <ul>
      <li>mouse wheel or trackpad scrolling,</li>
      <li>touch or pen dragging gestures,</li>
      <li>keyboard or keypad navigation,</li>
      <li>gamepad or switch device actions.</li>
    </ul>
    <p>
      Host environments translate such interactions into impulses that can be
      consumed by the scroll engine, or may choose to apply them directly to the
      scroll surface depending on the configured
      <a href="#term-scroll-authority">scroll authority</a>.
    </p>
  </section>

  <section id="term-origin">
    <h3 id="term-origin-heading">Origin</h3>
    <p>
      The <dfn id="term-origin">origin</dfn> of a position update is a tag
      indicating where the update came from. The following origins are defined:
    </p>
    <ul>
      <li>
        <code>"user"</code>: updates directly caused by user actions, such as
        wheel or touch input, keyboard navigation, or actions from assistive
        technologies.
      </li>
      <li>
        <code>"program"</code>: updates requested explicitly by application
        code, such as a scroll-to-section call.
      </li>
      <li>
        <code>"momentum"</code>: updates that continue motion initially caused
        by the user, such as inertial scrolling.
      </li>
    </ul>
  </section>

  <section id="term-scroll-authority">
    <h3 id="term-scroll-authority-heading">Scroll Authority</h3>
    <p>
      <dfn>Scroll authority</dfn> describes which component is responsible for
      applying position changes to a scroll surface for a given category of
      scroll action. This specification distinguishes two authorities:
    </p>
    <ul>
      <li>
        A <dfn id="term-user-scroll-authority">user scroll authority</dfn>,
        which determines whether user-originated impulses are applied to the
        scroll surface directly by the Host Environment or via the Scroll Engine
        Implementation.
      </li>
      <li>
        A
        <dfn id="term-programmatic-scroll-authority"
          >programmatic scroll authority</dfn
        >, which determines whether programmatic
        <a href="#term-scroll-operation">scroll operations</a> are applied to
        the scroll surface directly by the Host Environment or via the Scroll
        Engine Implementation.
      </li>
    </ul>
    <p>
      For each authority, the controlling component is called a
      <dfn>scroll controller</dfn>. A scroll controller
      <em class="rfc2119">MAY</em> be the Scroll Engine Implementation, the Host
      Environment, or a composition of both, as defined by host-specific
      bindings, provided that:
    </p>
    <ul>
      <li>
        the scroll engine can observe the resulting canonical positions and
        origins, and
      </li>
      <li>
        <a href="#accessibility">Accessibility</a> requirements, including user
        override, are satisfied.
      </li>
    </ul>
    <p>
      When the Host Environment is the scroll controller for user or
      programmatic scroll, it is responsible for applying motion to the scroll
      surface and informing the scroll engine of resulting positions and
      origins. When the Scroll Engine Implementation is the scroll controller,
      it is responsible for computing new positions (for example, via a motion
      policy) and communicating them to the scroll surface using host-defined
      mechanisms.
    </p>
  </section>
  <section id="scroll-authority-profiles">
    <h3 id="scroll-authority-profiles-heading">Scroll Authority Profiles</h3>
    <p>
      This section defines four common <dfn>scroll authority profiles</dfn> in
      terms of
      <a href="#term-user-scroll-authority">user scroll authority</a> and
      <a href="#term-programmatic-scroll-authority"
        >programmatic scroll authority</a
      >. Host Environments <em class="rfc2119">MAY</em> expose additional or
      more granular configurations, but any such configuration
      <em class="rfc2119">MUST</em> be reducible to these concepts.
    </p>

    <section id="profile-engine-engine">
      <h4 id="profile-engine-engine-heading">
        Engine-controlled profile (engine/engine)
      </h4>
      <p>
        In the <dfn>engine-controlled profile</dfn>, the Scroll Engine
        Implementation is both the
        <a href="#term-user-scroll-authority">user scroll authority</a> and the
        <a href="#term-programmatic-scroll-authority"
          >programmatic scroll authority</a
        >.
      </p>
      <ul>
        <li>
          User-originated input is translated into
          <a href="#term-impulse">impulses</a> and delivered to the scroll
          engine, which applies them according to the active
          <a href="#scroll-domain">scroll domain</a> and
          <a href="#term-motion-policy">motion policy</a>.
        </li>
        <li>
          Programmatic
          <a href="#term-scroll-operation">scroll operations</a> are also
          processed by the scroll engine, which computes and applies motion to
          the scroll surface.
        </li>
        <li>
          The scroll engine is responsible for writing resulting positions to
          the scroll surface using host-defined mechanisms.
        </li>
        <li>
          This profile <em class="rfc2119">MAY</em> support all domain kinds
          defined in <a href="#data-domains">Scroll Domains</a>, including
          circular domains whose behavior would not be expressible when only the
          Host Environment controls motion.
        </li>
      </ul>
    </section>

    <section id="profile-host-engine">
      <h4 id="profile-host-engine-heading">
        Host-user / engine-program profile (host/engine)
      </h4>
      <p>
        In the <dfn>host-user / engine-program profile</dfn>, the Host
        Environment is the
        <a href="#term-user-scroll-authority">user scroll authority</a>, and the
        Scroll Engine Implementation is the
        <a href="#term-programmatic-scroll-authority"
          >programmatic scroll authority</a
        >.
      </p>
      <ul>
        <li>
          User-originated input is applied directly to the scroll surface by the
          Host Environment using host-specific mechanisms (for example, native
          scrolling behavior). The resulting positions and origins
          <em class="rfc2119">MUST</em> be reported back to the scroll engine as
          canonical positions with origin <code>"user"</code> or
          <code>"momentum"</code>.
        </li>
        <li>
          Programmatic
          <a href="#term-scroll-operation">scroll operations</a> are processed
          by the scroll engine, which computes motion over time according to its
          <a href="#term-motion-policy">motion policy</a> and writes resulting
          positions to the scroll surface.
        </li>
        <li>
          When user-originated input occurs while programmatic motion is
          ongoing, user input <em class="rfc2119">MUST</em> take precedence as
          described in
          <a href="#a11y-user-override"
            >User Override and Priority of User Input</a
          >. Implementations <em class="rfc2119">SHOULD</em> cancel or adjust
          engine-driven motion in response to such input.
        </li>
        <li>
          Certain domain behaviors (for example, circular domains that require
          logical wrapping of the scroll surface)
          <em class="rfc2119">MAY</em> be limited or host-specific in this
          profile, since user-originated motion is applied directly by the Host
          Environment.
        </li>
      </ul>
    </section>

    <section id="profile-engine-host">
      <h4 id="profile-engine-host-heading">
        Engine-user / host-program profile (engine/host)
      </h4>
      <p>
        In the <dfn>engine-user / host-program profile</dfn>, the Scroll Engine
        Implementation is the
        <a href="#term-user-scroll-authority">user scroll authority</a>, and the
        Host Environment is the
        <a href="#term-programmatic-scroll-authority"
          >programmatic scroll authority</a
        >.
      </p>
      <ul>
        <li>
          User-originated input is translated into
          <a href="#term-impulse">impulses</a> and delivered to the scroll
          engine, which computes and applies resulting motion to the scroll
          surface.
        </li>
        <li>
          Programmatic
          <a href="#term-scroll-operation">scroll operations</a> are fulfilled
          by the Host Environment using host-specific mechanisms (for example,
          native smooth scrolling or discrete jumps). The Host Environment
          <em class="rfc2119">MUST</em> report resulting canonical positions and
          origins (typically <code>"program"</code>) back to the scroll engine.
        </li>
        <li>
          The scroll engine <em class="rfc2119">MUST</em> treat host-applied
          programmatic motion as observable state and
          <em class="rfc2119">MUST NOT</em> assume that it can override or
          replace that motion unless explicitly configured to do so by the Host
          Environment.
        </li>
        <li>
          This profile is suitable when user input must be handled in a
          highly-custom way by the engine, while programmatic scroll integrates
          closely with host-native behaviors.
        </li>
      </ul>
    </section>

    <section id="profile-host-host">
      <h4 id="profile-host-host-heading">
        Host-controlled profile (host/host)
      </h4>
      <p>
        In the <dfn>host-controlled profile</dfn>, the Host Environment is both
        the <a href="#term-user-scroll-authority">user scroll authority</a> and
        the
        <a href="#term-programmatic-scroll-authority"
          >programmatic scroll authority</a
        >.
      </p>
      <ul>
        <li>
          User-originated input and programmatic scroll operations are applied
          directly to the scroll surface by the Host Environment using
          host-specific mechanisms.
        </li>
        <li>
          The scroll engine acts as an observer: it
          <em class="rfc2119">MUST</em> be notified of resulting canonical
          positions and origins in order to drive
          <a href="#term-scroll-program">scroll programs</a>, scroll-linked
          effects, and persistence, but it
          <em class="rfc2119">MUST NOT</em> apply motion to the scroll surface
          in this profile.
        </li>
        <li>
          This profile is suitable when the primary goal is to coordinate
          scroll-linked effects, analytics, or persistence with host-native
          scrolling, without changing how scrolling itself is performed.
        </li>
        <li>
          Domain semantics, particularly for domains that require wrapping or
          logical repositioning of the scroll surface,
          <em class="rfc2119">MAY</em>
          be constrained by the capabilities of the Host Environment in this
          profile.
        </li>
      </ul>
    </section>

    <section id="profile-selection">
      <h4 id="profile-selection-heading">Profile selection</h4>
      <p>
        A Host Environment <em class="rfc2119">MAY</em> select different scroll
        authority profiles for different scroll surfaces or scroll axes, and
        <em class="rfc2119">MAY</em> allow applications to change profiles at
        runtime. When profiles change, the Host Environment
        <em class="rfc2119">MUST</em> ensure that:
      </p>
      <ul>
        <li>
          the scroll engine maintains a coherent view of canonical position,
          velocity, direction, and origin across the transition, and
        </li>
        <li>
          <a href="#accessibility">Accessibility</a> requirements, including
          user override and reduced motion, continue to be satisfied.
        </li>
      </ul>
    </section>
  </section>

  <section id="term-velocity-direction">
    <h3 id="term-velocity-direction-heading">Velocity and Direction</h3>
    <p>
      <dfn>Velocity</dfn> is a measure of the change in canonical position per
      unit time, as observed by the scroll engine. The exact units of velocity
      depend on the host environment’s choice of units for positions and time.
    </p>
    <p>
      <dfn>Direction</dfn> is the sign of the most recent non-zero velocity,
      commonly represented as:
    </p>
    <ul>
      <li><code>-1</code> for movement in the decreasing direction,</li>
      <li><code>0</code> for no movement,</li>
      <li><code>+1</code> for movement in the increasing direction.</li>
    </ul>
  </section>

  <section id="term-frame">
    <h3 id="term-frame-heading">Frame</h3>
    <p>
      A <dfn>frame</dfn> is a single evaluation step of the scroll engine in
      which it:
    </p>
    <ul>
      <li>considers any pending impulses and scroll operations,</li>
      <li>advances motion over time according to a motion policy, and</li>
      <li>updates observable state.</li>
    </ul>
    <p>
      In configurations where the Host Environment is the
      <a href="#term-programmatic-scroll-authority"
        >programmatic scroll authority</a
      >, the notion of a frame can still be used for observation and
      coordination, even if the host applies motion using its own scheduling or
      animation mechanisms.
    </p>
  </section>

  <section id="term-motion-policy">
    <h3 id="term-motion-policy-heading">Motion Policy</h3>
    <p>
      A <dfn id="term-motion-policy">motion policy</dfn> is an abstract
      component that determines how scroll positions evolve over time from the
      current position towards a target position. Examples include instantaneous
      jumps, exponential easing, critically damped motion, or fixed-duration
      transitions.
    </p>
    <p>
      The concrete representation of motion policies (for example, code,
      configuration objects, or declarative descriptions) is host-specific. This
      specification only requires that motion policies can be selected or
      replaced by host or application code in a controlled manner.
    </p>
    <p>
      When the Host Environment is the
      <a href="#term-programmatic-scroll-authority"
        >programmatic scroll authority</a
      >, motion policies may be expressed in host-specific APIs while still
      being conceptually aligned with this model.
    </p>
  </section>

  <section id="term-scroll-program">
    <h3 id="term-scroll-program-heading">Scroll Program</h3>
    <p>
      A <dfn id="term-scroll-program">scroll program</dfn> is host- or
      application-defined logic that observes or influences the behavior of a
      scroll engine via its programmable extension points. A scroll program may:
    </p>
    <ul>
      <li>observe scroll position, velocity, and direction,</li>
      <li>react to position or lifecycle changes,</li>
      <li>
        adjust targets or impulses within the constraints of the active scroll
        domain and configured
        <a href="#term-scroll-authority">scroll authorities</a>, or
      </li>
      <li>
        coordinate scroll position with other host-defined effects (for example,
        scroll-linked visual changes).
      </li>
    </ul>
    <p>
      This specification does not define a particular language or format for
      scroll programs; it only requires that conforming implementations provide
      a way for such logic to be attached and invoked.
    </p>
  </section>
</section>

<section id="data-model">
  <h2 id="data-model-heading">Data Model</h2>

  <section id="data-observable-state">
    <h3 id="data-observable-state-heading">Engine Observable State</h3>
    <p>
      A conforming Scroll Engine Implementation
      <em class="rfc2119">MUST</em> maintain and expose at least the following
      observable state:
    </p>
    <ul>
      <li>
        The current <a href="#term-scroll-position">canonical position</a>.
      </li>
      <li>
        The active <a href="#scroll-domain">scroll domain</a> and any domain
        parameters (such as <code>min</code>, <code>max</code>, and
        <code>period</code>).
      </li>
      <li>
        The current
        <a href="#term-velocity-direction">velocity and direction</a>, derived
        from changes in canonical position over time.
      </li>
      <li>
        A conceptual <dfn>target position</dfn>, representing the position
        towards which the engine is currently moving. In circular domains,
        implementations <em class="rfc2119">MAY</em> track both canonical and
        logical components of the target.
      </li>
      <li>
        A <dfn>running flag</dfn> indicating whether the engine considers the
        scroll to be “in motion” (for example, during ongoing animation or
        momentum) or idle.
      </li>
      <li>
        The configured
        <a href="#term-user-scroll-authority">user scroll authority</a> and
        <a href="#term-programmatic-scroll-authority"
          >programmatic scroll authority</a
        >
        for the axis, or an equivalent representation of which component
        currently controls user and programmatic motion.
      </li>
    </ul>
    <p>
      The concrete API shape used to expose this state is host- and
      language-specific, but conforming implementations
      <em class="rfc2119">MUST</em> provide some mechanism to observe it, and
      programmable extension points <em class="rfc2119">MUST</em> have access to
      this observable state.
    </p>
  </section>

  <section id="data-snapshot">
    <h3 id="data-snapshot-heading">Scroll State Snapshot</h3>
    <p>
      A <dfn>Scroll State Snapshot</dfn> captures the scroll engine’s position
      at a point in time for the purpose of persistence or restoration.
    </p>
    <p>
      A Scroll State Snapshot <em class="rfc2119">MUST</em> contain at least:
    </p>
    <ul>
      <li>
        An ordered collection of per-axis positions, where each axis state
        includes a <code>position</code> field representing the canonical
        position on that axis.
      </li>
      <li>
        A <dfn>timestamp</dfn> value, whose units are defined by the host
        environment (for example, milliseconds since epoch or a monotonic
        clock).
      </li>
    </ul>
    <p>An abstract shape for a Scroll State Snapshot is:</p>
    <pre><code>{
  axes: [{ position: &lt;number&gt; }, ...],
  timestamp: &lt;number&gt;
}</code></pre>
    <p>
      Host environments <em class="rfc2119">MAY</em> serialize snapshots to
      JSON, binary formats, or other representations suitable for their storage
      mechanisms.
    </p>
  </section>

  <section id="data-signals">
    <h3 id="data-signals-heading">Signals and Origins</h3>
    <p>
      A Scroll Engine Implementation <em class="rfc2119">MAY</em> expose
      position updates via an observable <dfn>scroll signal</dfn> abstraction. A
      scroll signal has:
    </p>
    <ul>
      <li>a current canonical position value, and</li>
      <li>a set of registered listeners.</li>
    </ul>
    <p>
      When the scroll engine updates the canonical position, it
      <em class="rfc2119">MAY</em> notify listeners with:
    </p>
    <ul>
      <li>the new canonical position, and</li>
      <li>
        the <a href="#term-origin">origin</a> of the update (user, program, or
        momentum).
      </li>
    </ul>
    <p>
      Errors thrown by listeners
      <em class="rfc2119">MUST NOT</em> compromise the scroll engine’s internal
      state or prevent further updates.
    </p>
    <p>
      Even if a scroll signal abstraction is not used, conforming
      implementations <em class="rfc2119">MUST</em> provide an equivalent
      mechanism for clients and scroll programs to observe position changes
      together with their origin.
    </p>
  </section>

  <section id="data-programmability">
    <h3 id="data-programmability-heading">Programmable Extension Points</h3>
    <p>
      A conforming Scroll Engine Implementation
      <em class="rfc2119">MUST</em> provide one or more abstract extension
      points that allow host or application code to participate in scroll
      behavior as <a href="#term-scroll-program">scroll programs</a>. Extension
      points are conceptual hook sites; their concrete API shapes are
      host-specific.
    </p>
    <p>
      At minimum, an implementation <em class="rfc2119">MUST</em> support the
      following categories of extension points:
    </p>
    <ul>
      <li>
        <dfn>Observation hooks</dfn>: mechanisms by which scroll programs can
        observe changes to canonical position, velocity, direction, domain
        parameters, target position, and the configured
        <a href="#term-scroll-authority">scroll authorities</a>.
      </li>
      <li>
        <dfn>Impulse hooks</dfn>: mechanisms by which scroll programs can
        observe or transform impulses before they are applied to the scroll
        engine, subject to domain constraints, accessibility requirements, and
        the configured
        <a href="#term-user-scroll-authority">user scroll authority</a>.
      </li>
      <li>
        <dfn>Target hooks</dfn>: mechanisms by which scroll programs can observe
        or adjust target positions derived from scroll operations or impulses,
        before motion is advanced according to a motion policy, and consistent
        with the configured
        <a href="#term-programmatic-scroll-authority"
          >programmatic scroll authority</a
        >.
      </li>
      <li>
        <dfn>Lifecycle hooks</dfn>: mechanisms that notify scroll programs about
        start, continuation, and settlement of motion, including access to
        <a href="#term-origin">origin</a> information.
      </li>
    </ul>
    <p>
      Implementations <em class="rfc2119">MUST</em> ensure that scroll programs
      cannot violate the semantics of the active scroll domain. For example, any
      transformed position or target <em class="rfc2119">MUST</em> be
      interpreted in terms of canonical and logical positions as defined in
      <a href="#data-domains">Scroll Domains</a>.
    </p>
    <p>
      Host environments <em class="rfc2119">MAY</em> expose these extension
      points as event listeners, callback registries, reactive signals, or other
      mechanisms, provided that the behavioral guarantees in this section are
      preserved.
    </p>
  </section>
</section>

<section id="accessibility">
  <h2 id="accessibility-heading">Accessibility</h2>

  <section id="a11y-principles">
    <h3 id="a11y-principles-heading">General Principles</h3>
    <p>
      A conforming Scroll Engine Implementation and its Host Environment
      <em class="rfc2119">MUST</em> support accessible scrolling experiences.
      This includes:
    </p>
    <ul>
      <li>
        Ensuring that the user remains in control of scroll motion, and that
        user input can override programmatic motion, including motion initiated
        by scroll programs, regardless of
        <a href="#term-scroll-authority">scroll authority</a> configuration.
      </li>
      <li>
        Respecting platform accessibility settings, including preferences for
        reduced motion or similar features.
      </li>
      <li>
        Supporting keyboard, keypad, switch, and other assistive input as
        first-class means of controlling scroll.
      </li>
      <li>
        Avoiding motion that cannot be paused, stopped, or overridden by the
        user.
      </li>
    </ul>
  </section>

  <!-- Remaining accessibility sections unchanged except where they already mention override etc. -->

  <section id="a11y-user-override">
    <h3 id="a11y-user-override-heading">
      User Override and Priority of User Input
    </h3>
    <p>
      When user-originated input conflicts with ongoing programmatic motion,
      user input <em class="rfc2119">MUST</em> take precedence.
    </p>
    <p>A Scroll Engine Implementation <em class="rfc2119">MUST</em>:</p>
    <ul>
      <li>
        Allow user impulses to override or modify the current target position,
        including in configurations where the engine is the
        <a href="#term-programmatic-scroll-authority"
          >programmatic scroll authority</a
        >.
      </li>
      <li>
        Stop, pause, or alter ongoing motion accordingly, rather than ignoring
        user attempts to stop or reverse the motion.
      </li>
    </ul>
    <p>
      Host Environments <em class="rfc2119">MUST</em> ensure that, when they are
      the <a href="#term-user-scroll-authority">user scroll authority</a>, user
      interactions can still interrupt or cancel host-driven scrolling behaviors
      (for example, host-native smooth scrolling) in a manner consistent with
      platform conventions.
    </p>
    <p>
      Engines <em class="rfc2119">MUST NOT</em> create non-cancelable,
      non-interruptible scroll loops that continue in spite of user input
      intended to stop or reverse them, including loops initiated or extended by
      scroll programs.
    </p>
  </section>
</section>

<section id="architecture" class="informative">
  <h2 id="architecture-heading">Architecture Overview (informative)</h2>
  <p class="note">
    This section is non-normative and describes the conceptual roles and
    interactions of components in a programmable scroll engine implementation.
  </p>

  <section id="arch-components">
    <h3 id="arch-components-heading">Component Roles</h3>
    <p>
      A typical system based on this specification includes the following
      conceptual components:
    </p>
    <ul>
      <li>
        A <dfn>Scroll Engine</dfn>, which maintains the scroll axis state as
        described in <a href="#data-model">Data Model</a>, accepts
        <a href="#term-scroll-operation">scroll operations</a> and
        <a href="#term-impulse">impulses</a>, and updates positions over time
        according to a <a href="#term-motion-policy">motion policy</a>.
      </li>
      <li>
        A <dfn>Scroll Surface</dfn>, a host-defined entity whose visible content
        changes in response to scroll position (for example, a DOM element,
        native scroll view, or camera).
      </li>
      <li>
        A <dfn>Motion Policy</dfn>, which defines how positions evolve over time
        from current to target (for example, instantaneous jumps, exponential
        easing, fixed-duration transitions). Motion policies can be selected or
        replaced under the control of scroll programs or host code.
      </li>
      <li>
        A <dfn>Scheduler</dfn>, which provides a notion of frames or time steps
        for the scroll engine (for example, display refresh, game loop, or
        timer-based updates).
      </li>
      <li>
        A set of <dfn>Input Sources</dfn>, which translate host-specific input
        events (pointer, keyboard, accessibility commands, etc.) into
        <a href="#term-impulse">impulses</a>, or apply such input directly to
        scroll surfaces when the Host Environment is the
        <a href="#term-user-scroll-authority">user scroll authority</a>.
      </li>
      <li>
        A <dfn>Scroll Authority Configuration</dfn>, which declares the
        <a href="#term-user-scroll-authority">user scroll authority</a> and
        <a href="#term-programmatic-scroll-authority"
          >programmatic scroll authority</a
        >
        for each scroll axis, and thereby determines which component applies
        motion for user and programmatic actions.
      </li>
      <li>
        A collection of <dfn>Scroll Programs</dfn>, which attach to the engine’s
        extension points to implement custom behavior, such as snapping,
        scroll-linked effects, or application-specific rules.
      </li>
      <li>
        A <dfn>Persistence Layer</dfn>, which reads and writes
        <a href="#data-snapshot">Scroll State Snapshots</a> to storage
        appropriate for the Host Environment.
      </li>
    </ul>
  </section>

  <section id="arch-flow">
    <h3 id="arch-flow-heading">Execution Flow (Conceptual)</h3>
    <p>The high-level execution flow in a system based on this model is:</p>
    <ol>
      <li>
        User input is received by the Host Environment and either:
        <ul>
          <li>
            translated into impulses or scroll operations that are passed to the
            Scroll Engine (when the engine is the
            <a href="#term-user-scroll-authority">user scroll authority</a>), or
          </li>
          <li>
            applied directly to the scroll surface by the Host Environment (when
            the host is the user scroll authority), with corresponding position
            updates reported back to the Scroll Engine.
          </li>
        </ul>
      </li>
      <li>
        Programmatic scroll operations are requested by application code or
        scroll programs and either:
        <ul>
          <li>
            processed by the Scroll Engine, which updates positions over time
            according to the active motion policy (when the engine is the
            <a href="#term-programmatic-scroll-authority"
              >programmatic scroll authority</a
            >), or
          </li>
          <li>
            applied directly by the Host Environment using host-specific
            mechanisms (for example, native smooth scrolling), with resulting
            positions reported to the Scroll Engine (when the host is the
            programmatic scroll authority).
          </li>
        </ul>
      </li>
      <li>
        The Scroll Engine updates its internal state and computes a new
        canonical position according to the active scroll domain and motion
        policy, possibly after transformation of impulses or targets by scroll
        programs, and consistent with the configured scroll authorities.
      </li>
      <li>
        The new canonical position is applied to the Scroll Surface using
        host-specific mechanisms (for example, DOM scroll offsets or native view
        properties) when the Scroll Engine is the relevant scroll controller, or
        is observed from the host when the Host Environment is the controller.
      </li>
      <li>
        The Scroll Engine notifies observers (such as applications, scroll
        programs, or persistence modules) via its observable mechanisms.
      </li>
      <li>
        Persistence modules, if present, record snapshots of scroll state at
        appropriate times.
      </li>
    </ol>
    <p>
      At all times, user input
      <em class="rfc2119">MUST</em> be able to override programmatic motion, as
      detailed in <a href="#accessibility">Accessibility</a>, regardless of
      whether the Scroll Engine Implementation or the Host Environment is the
      active scroll controller.
    </p>
  </section>
</section>
